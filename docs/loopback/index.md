# Loopback 4

- [x] Database Connectors
- [x] Model
- [x] Relations

## Database Connectors

- [https://loopback.io/doc/en/lb4/Database-connectors.html](https://loopback.io/doc/en/lb4/Database-connectors.html)

### PostgreSQL Connector

```sh
npm install loopback-connector-postgresql --save
```

> Create datasource

```sh
lb4 datasource
```

```ts
// ./src/datasources/english.datasource.ts
import { inject, lifeCycleObserver, LifeCycleObserver } from "@loopback/core";
import { juggler } from "@loopback/repository";

const config = {
  name: "english",
  connector: "postgresql",
  url: "postgres://postgres_dev:123456@localhost:5432/english_api",
};

// Observe application's life cycle to disconnect the datasource when
// application is stopped. This allows the application to be shut down
// gracefully. The `stop()` method is inherited from `juggler.DataSource`.
// Learn more at https://loopback.io/doc/en/lb4/Life-cycle.html
@lifeCycleObserver("datasource")
export class EnglishDataSource
  extends juggler.DataSource
  implements LifeCycleObserver
{
  static dataSourceName = "english";
  static readonly defaultConfig = config;

  constructor(
    @inject("datasources.config.english", { optional: true })
    dsConfig: object = config
  ) {
    super(dsConfig);
  }
}
```

### Debug Database Query

**Linux**

```sh
DEBUG=loopback:connector* npm start
```

**Window**

```sh
set DEBUG=loopback:connector* && npm start
```

## Model

- [https://loopback.io/doc/en/lb4/Model.html](https://loopback.io/doc/en/lb4/Model.html)

### Definition

> A **Model** describes business domain objects, for example: Task, TaskStatus and Project. It usually defines a list of properties with name, type, and other constraints(format, min, max, ...).

> Model can be used for data exchanged between client-server or different systems.

> Model definitions can be mapped to many forms: relational database schemas, JSON schemas, OpenAPI Schemas, gRPC message definitions,...

> A JSON Object conforming to the Task model definition can be passed in REST/HTTP payload to create a new Task or stored in a document database such as Mongo

There are 2 subtly different types of models for domain objects:

- Entity : A domain object that has an identity (ID). Its equality is based on the identity.
- Model: A domain object that does not have an identity (ID). Its equality is based on the structural value

```ts
@model()
export class Task extends Entity {
  @property({
    type: "string",
    id: true,
    defaultFn: "uuid",
  })
  id?: string;

  @property({
    type: "string",
    required: true,
    postgresql: {
      dataType: "VARCHAR",
      dataLength: 120,
    },
  })
  name: string;
}

@model()
export class SocialLink {
  @property({
    type: "string",
    required: true,
  })
  linkType: string;

  @property({
    type: "string",
    required: true,
  })
  link: string;
}
```

### ID - How to create auto increment for ID property?

```ts
{
  id: true,
  type: 'Number',
  required: false,
  generated: true // enables auto-generation
}
```

### How to use UUID?

> use uuid that is generated by your LB application by setting defaultFn: uuid

```ts
@property({
    id: true,
    type: 'string'
    defaultFn: 'uuid',
    // generated: true,  -> not needed
  })
id: string;
```

> use PostgreSQL built-in (extension and) uuid functions

```ts
@property({
  id: true,
  type: 'String',
  required: false,
  // settings below are needed
  generated: true,
  useDefaultIdType: false,
  postgresql: {
    dataType: 'uuid',
  },
})
id: string;
```

The setting uses uuid-ossp extension and uuid_generate_v4() function as default.

> If youâ€™d like to use other extensions and functions, you can do:

```ts
 @property({
  id: true,
  type: 'String',
  required: false,
  // settings below are needed
  generated: true,
  useDefaultIdType: false,
  postgresql: {
    dataType: 'uuid',
    extension: 'myExtension',
    defaultFn: 'myuuid'
  },
})
id: string;
```

### Common data types mapping

- [PostSQL Data Type Mapping](https://loopback.io/doc/en/lb4/PostgreSQL-connector.html)

![image](https://user-images.githubusercontent.com/31009750/216272587-1ebd5218-96cd-4af0-8831-96d3e6eb93ee.png)

```ts
import { model, property } from "@loopback/repository";
import { BaseEntity } from "./base.entity";

@model({
  settings: {
    idInjection: false,
    postgresql: { schema: "public", table: "sample" },
  },
})
export class Sample extends BaseEntity {
  @property({
    type: "string",
    length: 30,

    postgresql: {
      columnName: "short_string_prop",
      dataType: "character varying",
      dataLength: 30,
      dataPrecision: null,
      dataScale: null,
      nullable: "YES",
    },
  })
  shortStringProp?: string;

  @property({
    type: "string",
    length: 120,

    postgresql: {
      columnName: "long_string_prop",
      dataType: "character varying",
      dataLength: 120,
      dataPrecision: null,
      dataScale: null,
      nullable: "YES",
    },
  })
  longStringProp?: string;

  @property({
    type: "string",

    postgresql: {
      columnName: "text_prop",
      dataType: "text",
      nullable: "YES",
    },
  })
  textProp?: string;

  @property({
    type: "string",
    length: 1,

    postgresql: {
      columnName: "char_prop",
      dataType: "character",
      dataLength: 1,
      dataPrecision: null,
      dataScale: null,
      nullable: "YES",
    },
  })
  charProp?: string;

  @property({
    type: "boolean",

    postgresql: {
      columnName: "bool_prop",
      dataType: "boolean",
      nullable: "YES",
    },
  })
  boolProp?: boolean;

  @property({
    type: "string",
    required: false,
    postgresql: {
      columnName: "buffer_prop",
      dataType: "bytea",
      nullable: "YES",
    },
  })
  bufferProp?: string;

  @property({
    type: "number",
    scale: 0,

    postgresql: {
      columnName: "int_prop",
      dataType: "integer",
      dataLength: null,
      dataPrecision: null,
      dataScale: 0,
      nullable: "YES",
    },
  })
  intProp?: number;

  @property({
    type: "number",
    scale: 0,

    postgresql: {
      columnName: "bigint_prop",
      dataType: "bigint",
      dataLength: null,
      dataPrecision: null,
      dataScale: 0,
      nullable: "YES",
    },
  })
  bigintProp?: number;

  @property({
    type: "number",
    precision: 53,

    postgresql: {
      columnName: "double_prop",
      dataType: "float",
      dataLength: null,
      dataPrecision: 53,
      dataScale: null,
      nullable: "YES",
    },
  })
  doubleProp?: number;

  @property({
    type: "date",

    postgresql: {
      columnName: "date_prop",
      dataType: "date",
      nullable: "YES",
    },
  })
  dateProp?: string;

  @property({
    type: "date",

    postgresql: {
      columnName: "timestamptz_prop",
      dataType: "timestamp with time zone",
      nullable: "YES",
    },
  })
  timestamptzProp?: string;

  @property({
    type: "string",

    postgresql: {
      columnName: "time_prop",
      dataType: "time",
      nullable: "YES",
    },
  })
  timeProp?: string;

  @property({
    type: "string",

    postgresql: {
      columnName: "point_prop",
      dataType: "point",
      nullable: "YES",
    },
  })
  pointProp?: string;

  @property({
    type: "object",

    postgresql: {
      columnName: "json_prop",
      dataType: "json",
      nullable: "YES",
    },
  })
  jsonProp?: object;

  @property({
    type: "array",
    itemType: "string",

    postgresql: {
      columnName: "array_string_prop",
      dataType: "varchar[]",
      nullable: "YES",
    },
  })
  arrayStringProp?: string[];

  // Define well-known properties here

  // Indexer property to allow additional data
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  [prop: string]: any;

  constructor(data?: Partial<Sample>) {
    super(data);
  }
}

export interface Point {
  lat: number;
  lng: number;
}

export interface SampleRelations {
  // describe navigational properties here
}

export type SampleWithRelations = Sample & SampleRelations;
```

Data validation

```ts
import { model, property } from "@loopback/repository";
import { IsISO8601, IsNotEmpty, Max, MaxLength, Min } from "class-validator";
import { IsValidTime } from "./validator";

@model()
export class CreateSampleDto {
  @property({
    required: true,
  })
  @IsNotEmpty()
  @MaxLength(30)
  shortStringProp: string;

  @property({
    required: true,
  })
  @IsNotEmpty()
  @MaxLength(120)
  longStringProp?: string;

  @property()
  textProp?: string;

  @property()
  charProp?: string;

  @property()
  boolProp?: boolean;

  @property()
  bufferProp?: string;

  @property({
    required: true,
  })
  @IsNotEmpty()
  @Min(0)
  @Max(Number.MAX_SAFE_INTEGER)
  intProp?: number;

  @property({
    required: true,
  })
  @IsNotEmpty()
  @Min(0)
  @Max(Number.MAX_VALUE)
  bigintProp?: number;

  @property({
    required: true,
  })
  @IsNotEmpty()
  @Max(Number.MAX_VALUE)
  doubleProp?: number;

  @property()
  @IsISO8601()
  dateProp?: string;

  @property()
  @IsISO8601()
  timestamptzProp?: string;

  @property()
  @IsValidTime()
  timeProp?: string;

  @property()
  pointProp?: string;

  @property()
  jsonProp?: object;

  @property({
    type: "array",
    itemType: "string",
  })
  arrayStringProp?: string[];
}
```

### Auto updated model properties createdAt and updatedAt

- https://github.com/loopbackio/loopback-next/issues/1857

> BaseEntity

```ts
// ./src/models/base.entity.ts
import { Entity, property } from "@loopback/repository";

export abstract class BaseEntity extends Entity {
  @property({
    type: "string",
    id: true,
    defaultFn: "uuid",
  })
  id?: string;

  @property({
    type: "Date",
    name: "created_at",
  })
  createdAt?: Date;

  @property({
    type: "Date",
    name: "updated_at",
  })
  updatedAt?: Date;

  constructor(data?: Partial<BaseEntity>) {
    super(data);
  }
}

// ./src/models/todo.model.ts
import { model, property } from "@loopback/repository";
import { BaseEntity } from "./base.entity";

@model()
export class Todo extends BaseEntity {
  @property({
    type: "string",
    required: true,
  })
  title: string;

  @property({
    type: "boolean",
  })
  isComplete?: boolean;

  constructor(data?: Partial<Todo>) {
    super(data);
  }
}

export interface TodoRelations {
  // describe navigational properties here
}

export type TodoWithRelations = Todo & TodoRelations;
```

> TimestampRepositoryMixin

- [Loopback 4 Mixins](https://loopback.io/doc/en/lb4/Mixin.html)
- [Typescript Mixins](https://www.typescriptlang.org/docs/handbook/mixins.html)
- [Javascript Mixins](https://javascript.info/mixins)

```ts
// ./src/mixins/time-stamp.mixin.ts
import { Constructor } from "@loopback/core";
import {
  Count,
  DataObject,
  Entity,
  EntityCrudRepository,
  Options,
  Where,
} from "@loopback/repository";

export function TimeStampRepositoryMixin<
  E extends Entity & { createdAt?: Date; updatedAt?: Date },
  ID,
  R extends Constructor<EntityCrudRepository<E, ID>>
>(repository: R) {
  class MixedRepository extends repository {
    async create(entity: DataObject<E>, options?: Options): Promise<E> {
      entity.createdAt = new Date();
      entity.updatedAt = new Date();
      return super.create(entity, options);
    }

    async updateAll(
      data: DataObject<E>,
      where?: Where<E>,
      options?: Options
    ): Promise<Count> {
      data.updatedAt = new Date();
      return super.updateAll(data, where, options);
    }

    async replaceById(
      id: ID,
      data: DataObject<E>,
      options?: Options
    ): Promise<void> {
      data.updatedAt = new Date();
      return super.replaceById(id, data, options);
    }

    async updateById(
      id: ID,
      data: DataObject<E>,
      options?: Options
    ): Promise<void> {
      data.updatedAt = new Date();
      return super.updateById(id, data, options);
    }
  }
  return MixedRepository;
}

// ./src/repositories/todo.repository.ts

import { TimeStampRepositoryMixin } from "@english/mixins/time-stamp.mixin";
import { Constructor, inject } from "@loopback/core";
import { DefaultCrudRepository } from "@loopback/repository";
import { EnglishDataSource } from "../datasources";
import { Todo, TodoRelations } from "../models";

export class TodoRepository extends TimeStampRepositoryMixin<
  Todo,
  typeof Todo.prototype.id,
  Constructor<
    DefaultCrudRepository<Todo, typeof Todo.prototype.id, TodoRelations>
  >
>(DefaultCrudRepository) {
  constructor(@inject("datasources.english") dataSource: EnglishDataSource) {
    super(Todo, dataSource);
  }
}
```

### Migrate data to create/update schema

![image](https://user-images.githubusercontent.com/31009750/216074402-895555e4-c0f7-475b-b00a-abe89cc66008.png)

```json
"migrate:setup": "\"npm run rebuild\" && node ./dist/migrate --rebuild",
"migrate": "\"npm run rebuild\" && node ./dist/migrate node ./dist/migrate",
```

```ts
// ./migrate.ts
import { EnglishApi } from "./application";
import { Task, Todo } from "./models";
import { Sample } from "./models/sample.model";

export async function migrate(args: string[]) {
  const existingSchema = args.includes("--rebuild") ? "drop" : "alter";
  console.log("Migrating schemas (%s existing schema)", existingSchema);

  const app = new EnglishApi();
  await app.boot();
  await app.migrateSchema({
    existingSchema,
    // The order of table creation is important.
    // A referenced table must exist before creating a
    // foreign key constraint.
    // For PostgreSQL connector, it does not create tables in the
    // right order.  Therefore, this change is needed.
    models: [Todo.name, Task.name, Sample.name],
  });

  // Connectors usually keep a pool of opened connections,
  // this keeps the process running even after all work is done.
  // We need to exit explicitly.
  process.exit(0);
}

migrate(process.argv).catch((err) => {
  console.error("Cannot migrate database schema", err);
  process.exit(1);
});
```

## Relations

- [References from Loopback Official Document](https://loopback.io/doc/en/lb4/Relations.html)

### One To One Relationship

![image](https://user-images.githubusercontent.com/31009750/216505076-cd331072-94ad-4606-8136-620c9e95e3d1.png)
