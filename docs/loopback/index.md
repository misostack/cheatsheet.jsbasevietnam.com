# Loopback 4

- [x] Database Connectors
- [x] Model

## Database Connectors

- [https://loopback.io/doc/en/lb4/Database-connectors.html](https://loopback.io/doc/en/lb4/Database-connectors.html)

### PostgreSQL Connector

```sh
npm install loopback-connector-postgresql --save
```

> Create datasource

```sh
lb4 datasource
```

```ts
// ./src/datasources/english.datasource.ts
import { inject, lifeCycleObserver, LifeCycleObserver } from "@loopback/core";
import { juggler } from "@loopback/repository";

const config = {
  name: "english",
  connector: "postgresql",
  url: "postgres://postgres_dev:123456@localhost:5432/english_api",
};

// Observe application's life cycle to disconnect the datasource when
// application is stopped. This allows the application to be shut down
// gracefully. The `stop()` method is inherited from `juggler.DataSource`.
// Learn more at https://loopback.io/doc/en/lb4/Life-cycle.html
@lifeCycleObserver("datasource")
export class EnglishDataSource
  extends juggler.DataSource
  implements LifeCycleObserver
{
  static dataSourceName = "english";
  static readonly defaultConfig = config;

  constructor(
    @inject("datasources.config.english", { optional: true })
    dsConfig: object = config
  ) {
    super(dsConfig);
  }
}
```

## Model

- [https://loopback.io/doc/en/lb4/Model.html](https://loopback.io/doc/en/lb4/Model.html)

### Definition

> A **Model** describes business domain objects, for example: Task, TaskStatus and Project. It usually defines a list of properties with name, type, and other constraints(format, min, max, ...).

> Model can be used for data exchanged between client-server or different systems.

> Model definitions can be mapped to many forms: relational database schemas, JSON schemas, OpenAPI Schemas, gRPC message definitions,...

> A JSON Object conforming to the Task model definition can be passed in REST/HTTP payload to create a new Task or stored in a document database such as Mongo

There are 2 subtly different types of models for domain objects:

- Entity : A domain object that has an identity (ID). Its equality is based on the identity.
- Model: A domain object that does not have an identity (ID). Its equality is based on the structural value

```ts
@model()
export class Task extends Entity {
  @property({
    type: "string",
    id: true,
    defaultFn: "uuid",
  })
  id?: string;

  @property({
    type: "string",
    required: true,
    postgresql: {
      dataType: "VARCHAR",
      dataLength: 120,
    },
  })
  name: string;
}

@model()
export class SocialLink {
  @property({
    type: "string",
    required: true,
  })
  linkType: string;

  @property({
    type: "string",
    required: true,
  })
  link: string;
}
```

### ID - How to create auto increment for ID property?

```ts
{
  id: true,
  type: 'Number',
  required: false,
  generated: true // enables auto-generation
}
```

### How to use UUID?

> use uuid that is generated by your LB application by setting defaultFn: uuid

```ts
@property({
    id: true,
    type: 'string'
    defaultFn: 'uuid',
    // generated: true,  -> not needed
  })
id: string;
```

> use PostgreSQL built-in (extension and) uuid functions

```ts
@property({
  id: true,
  type: 'String',
  required: false,
  // settings below are needed
  generated: true,
  useDefaultIdType: false,
  postgresql: {
    dataType: 'uuid',
  },
})
id: string;
```

The setting uses uuid-ossp extension and uuid_generate_v4() function as default.

> If youâ€™d like to use other extensions and functions, you can do:

```ts
 @property({
  id: true,
  type: 'String',
  required: false,
  // settings below are needed
  generated: true,
  useDefaultIdType: false,
  postgresql: {
    dataType: 'uuid',
    extension: 'myExtension',
    defaultFn: 'myuuid'
  },
})
id: string;
```

### Common data types mapping

- [PostSQL Data Type Mapping](https://loopback.io/doc/en/lb4/PostgreSQL-connector.html)

### Auto updated model properties createdAt and updatedAt

- https://github.com/loopbackio/loopback-next/issues/1857

### Migrate data to create/update schema

![image](https://user-images.githubusercontent.com/31009750/216074402-895555e4-c0f7-475b-b00a-abe89cc66008.png)

```json
"migrate:setup": "\"npm run rebuild\" && node ./dist/migrate --rebuild",
"migrate": "\"npm run rebuild\" && node ./dist/migrate node ./dist/migrate",
```

```ts
// ./migrate.ts
import { EnglishApi } from "./application";
import { Task, Todo } from "./models";
import { Sample } from "./models/sample.model";

export async function migrate(args: string[]) {
  const existingSchema = args.includes("--rebuild") ? "drop" : "alter";
  console.log("Migrating schemas (%s existing schema)", existingSchema);

  const app = new EnglishApi();
  await app.boot();
  await app.migrateSchema({
    existingSchema,
    // The order of table creation is important.
    // A referenced table must exist before creating a
    // foreign key constraint.
    // For PostgreSQL connector, it does not create tables in the
    // right order.  Therefore, this change is needed.
    models: [Todo.name, Task.name, Sample.name],
  });

  // Connectors usually keep a pool of opened connections,
  // this keeps the process running even after all work is done.
  // We need to exit explicitly.
  process.exit(0);
}

migrate(process.argv).catch((err) => {
  console.error("Cannot migrate database schema", err);
  process.exit(1);
});
```
